# Score.dev spec compliant example - web service with database
# This demonstrates the core Score.dev use case: application with dependencies
apiVersion: score.dev/v1b1
kind: Workload
metadata:
  labels:
    app.kubernetes.io/name: kbinit
    app.kubernetes.io/managed-by: kustomize
  name: service-a
  namespace: default
spec:
  service:
    ports:
      - port: 8000
        targetPort: 80
        protocol: TCP
  containers:
    container-id:
      image: busybox
      variables:
        CONNECTION_STRING: "postgresql://${resources.db.username}:${resources.db.password}@${resources.db.host}:${resources.db.port}"
  resources:
    db:
      type: postgres
---
# Test Case 2: Selector matching - batch workload
apiVersion: score.dev/v1b1
kind: Workload
metadata:
  labels:
    workload-type: batch
  name: workload-batch
  namespace: score-system
spec:
  containers:
    worker:
      image: busybox:latest
      command: ["sleep", "3600"]
  resources:
    storage:
      type: postgres
---
# Test Case 3: User hint - explicit profile annotation
apiVersion: score.dev/v1b1
kind: Workload
metadata:
  annotations:
    score.dev/profile: "batch-job"
  name: workload-user-hint
  namespace: score-system
spec:
  containers:
    app:
      image: nginx:latest
  resources:
    data:
      type: postgres
---
# Test environments for backend constraint testing
apiVersion: v1
kind: Namespace
metadata:
  name: test-dev
  # Per ADR-0004: Removed environment labels - cluster-level environment model
---
apiVersion: v1
kind: Namespace
metadata:
  name: test-prod
  # Per ADR-0004: Removed environment labels - cluster-level environment model
---
# Test Case 4: Web service - backend selection based on profile and features
apiVersion: score.dev/v1b1
kind: Workload
metadata:
  name: web-app-dev
  namespace: test-dev
  labels:
    app: web-app
    team: backend  # Organizational label
spec:
  containers:
    app:
      image: "nginx:latest"
      resources:
        requests:
          cpu: "200m"
          memory: "256Mi"
  service:
    ports:
    - port: 8080
      protocol: TCP
  resources:
    cache:
      type: redis
---
# Test Case 5: Web service with monitoring - backend selection based on features
apiVersion: score.dev/v1b1
kind: Workload
metadata:
  name: web-app-prod
  namespace: test-prod
  labels:
    app: web-app
  annotations:
    score.dev/requirements: "monitoring"
spec:
  containers:
    app:
      image: "nginx:latest"
      resources:
        requests:
          cpu: "500m"
          memory: "1Gi"
  service:
    ports:
    - port: 8080
      protocol: TCP
---
# Test Case 6: Batch workload with resource constraints
apiVersion: score.dev/v1b1
kind: Workload
metadata:
  name: batch-heavy
  namespace: test-dev
  labels:
    workload-type: batch
spec:
  containers:
    worker:
      image: "busybox:latest"
      command: ["sleep", "3600"]
      resources:
        requests:
          cpu: "4000m"
          memory: "8Gi"
  resources:
    queue:
      type: redis
---
# Test Case 7: Feature auto-detection - database connectivity
apiVersion: score.dev/v1b1
kind: Workload
metadata:
  name: app-with-db
  namespace: test-dev
  labels:
    team: backend  # Organizational label
spec:
  containers:
    app:
      image: "myapp:latest"
      resources:
        requests:
          cpu: "100m"
          memory: "128Mi"
  service:
    ports:
    - port: 3000
  resources:
    database:
      type: postgres
